/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

//! Magic dom object support
//! 
//! Magic dom objects act like normal dom objects but take no space on
//! the heap. Instead, fields are stored in reserved slots in the JSObject.
//! When a field is dereferenced, it converts from the corresponding
//! reserved slot value into the desired type. When a field is assigned,
//! the value is converted to a JS value and stored in a reserved slot.
//!
//! Magic dom objects actually store a rooted pointer to a JSObject. This
//! pointer is not represented in magic dom objects, but is used by the
//! fields to access the slots.
//!
//! The magic_dom_object macro takes a struct definition for a dom 
//! object and converts it to a magic dom object.

use core::nonzero::NonZero;
use std::cell::Cell;
use std::marker::PhantomData;
use std::mem;
use std::rc::Rc;
use std::sync::Arc;
use std::intrinsics::return_address;
use std::ops::{Deref, DerefMut};
use js::jsapi::{JS_GetReservedSlot, JS_SetReservedSlot, JSObject, JSContext, JSClass, Class};
use js::jsapi::{JS_NewUCStringCopyN, Rooted, RootedObject, RootedValue, ContextFriendFields};
use js::jsapi::{JSAutoRequest, JSAutoCompartment, JS_NewObjectWithGivenProto, HandleObject, HandleValue};
use js::jsapi::{JS_SetPrototype, JSTracer};
use js::jsapi::ThingRootKind;
use js::jsval::JSVal;
use js::jsval::{UndefinedValue, ObjectOrNullValue, DoubleValue, ObjectValue};
use js::jsval::{Int32Value, UInt32Value, BooleanValue, PrivateValue, StringValue};
use js::rust::{ToString, GCMethods};
use js::glue::{NewProxyObject, SetProxyExtra};

use dom::bindings::codegen::PrototypeList;
use dom::bindings::codegen::RegisterBindings;
use dom::bindings::conversions::{FromJSValConvertible, jsstring_to_str};
use dom::bindings::conversions::native_from_reflector_jsmanaged;
use dom::bindings::global::GlobalRef;
use dom::bindings::trace::{JSTraceable, trace_hook};
use dom::bindings::utils::{get_proto_or_iface_array, create_dom_global, trace_global};
use dom::bindings::js::{Root, LayoutJS, JS, JSObjectConversion, JSValConversion, DOMVec, ReadOnlyDOMVec, DOMMap, get_tls_jsctx};
use dom::bindings::str::ByteString;

use script_task::LAYOUT_LOCK;
use util::task_state;
use util::mem::HeapSizeOf;
use num::FromPrimitive;

/// A trait implemented for all fields that indicates
/// the start of the private slot index that this field uses.
/// This is always autogenerated.
pub trait SlotIndex {
    /// The starting slot index at which the data used for magic fields is stored.
    const IDX: u8;
}

/// A trait implemented on all magic DOM objects
/// containing code generated by the magic plugin.
/// This is always autogenerated.
pub trait SlotCount {
    /// The number of reserved slots that this object uses for
    /// magic fields.
    const SLOT_COUNT: u8;
    /// True if any slot requires a custom finalization call.
    const NEED_FINALIZE: bool;
    /// True if any slot contains a heap type. See `MagicCastable` for details.
    const HEAP_TYPE: bool;
    /// Runs any finalizers, if necessary.
    /// Should only be run if `NEED_FINALIZE` is true.
    unsafe fn finalize(&self);
    /// Returns a JS wrapper for this object's reserved slots.
    fn get_access_code() -> String;
}

/// A callback used in JSClass to finalize any slots that may need it.
pub unsafe extern fn finalize_hook<T: MagicDOMClass>(_fop: *mut ::js::jsapi::FreeOp, obj: *mut JSObject) {
    let this: &T = mem::transmute(&obj);
    this.finalize()
}

/// A trait implemented on all magic DOM objects.
/// This is generated by Codegen
pub trait MagicDOMClass : SlotCount {
    /// This is the prototype ID.
    const PROTO_ID: u32;
    /// This is the prototype depth, i.e., the number of interfaces this
    /// interface inherits from.
    const PROTO_DEPTH: usize;
    /// Determines whether this object is wrapped by a proxy
    const PROXIED: Option<PrototypeList::Proxies>;
    /// Determines whether there are any children that inherit this class.
    /// If not, we can use a fastpath for certain checks and only check
    /// JSClass pointers. This is required for "anonymous" DOM objects.
    const FINAL: bool;

    /// Gets a prototype object for this object, if needed.
    fn create_proto(cx: *mut JSContext, global: HandleObject) -> *mut JSObject;
    /// Gets the JSClass of this object.
    /// Can be null for "anonymous" DOM objects or objects that require proxies.
    fn get_jsclass() -> *const Class;

    /// Gets the underlying JSObject
    fn get_jsobj(&self) -> *mut JSObject {
        let real = self as *const _ as *const *mut JSObject;
        unsafe { *real }
    }

    /// Gets a HandleObject to the underlying JSObject.
    fn handle(&self) -> HandleObject {
        unsafe { HandleObject::from_marked_location(self as *const _ as *const *mut JSObject) }
    }
}

/// A special root used for initializing freshly made dom objects.
/// Unlike `Root<T>` this can't be moved.
#[repr(C)]
pub struct InitRoot<T: MagicDOMClass> {
    stack: *mut *mut Rooted<*mut ::libc::c_void>,
    prev: *mut Rooted<*mut ::libc::c_void>,
    ptr: InitFields,
    phantom: PhantomData<T>,
}

impl<T: MagicDOMClass> InitRoot<T> {
    fn new(cx: *mut JSContext, obj: *mut JSObject, addr: *const u8)
           -> InitRoot<T> {
        let ctxfriend: &mut ContextFriendFields = unsafe {
            mem::transmute(cx)
        };

        let kind = ThingRootKind::THING_ROOT_OBJECT as usize;
        let root = InitRoot::<T> {
            stack: &mut ctxfriend.thingGCRooters[kind],
            prev: ctxfriend.thingGCRooters[kind],
            ptr: InitFields {
                real: RealFields {
                    obj: Cell::new(obj),
                },
                count: 0,
            },
            phantom: PhantomData,
        };

        ctxfriend.thingGCRooters[kind] = unsafe { mem::transmute(addr) };
        root
    }

    /// Get a mutable reference to the object.
    pub fn r<'a>(&mut self) -> &'a mut T {
        unsafe { mem::transmute(&mut self.ptr) }
    }

    /// Freezes the fields by converting this InitRoot into an ordinary Root.
    /// All fields must be initialized at this point.
    pub fn into_root(&self) -> Root<T> {
        debug_assert!(T::SLOT_COUNT as u32 == self.ptr.count);
        unsafe {
            Root::new(NonZero::new(self.ptr.real.obj.get()))
        }
    }
}

impl<T: MagicDOMClass> Deref for InitRoot<T> {
    type Target = T;
    fn deref<'a>(&'a self) -> &'a T {
        unsafe { &*((&self.ptr.real.obj) as *const _ as *const T) }
    }
}

impl<T: MagicDOMClass> DerefMut for InitRoot<T> {
    fn deref_mut<'a>(&'a mut self) -> &'a mut T {
        unsafe { &mut *((&mut self.ptr.real.obj) as *mut _ as *mut T) }
    }
}

impl<T: MagicDOMClass> Drop for InitRoot<T> {
    fn drop(&mut self) {
        unsafe {
            assert!(*self.stack == mem::transmute(&*self));
            debug_assert!(self.ptr.count == T::SLOT_COUNT as u32);
            *self.stack = self.prev;
        }
    }
}

fn get_proto_object<T: MagicDOMClass>(cx: *mut JSContext, global: HandleObject)
                                      -> *mut JSObject
{
    if T::PROTO_ID == PrototypeList::ID::Count as u32 {
        return ptr::null_mut();
    }

    let proto_or_iface_array = unsafe { &mut *get_proto_or_iface_array(global.get()) };

    let proto = proto_or_iface_array[T::PROTO_ID as usize];
    if !proto.is_null() {
        return proto;
    }

    let proto = T::create_proto(cx, global);
    assert!(!proto.is_null());
    proto_or_iface_array[T::PROTO_ID as usize] = proto;
    if <*mut JSObject>::needs_post_barrier(proto) {
        unsafe {
            <*mut JSObject>::post_barrier(proto_or_iface_array.as_mut_ptr().offset(T::PROTO_ID as isize));
        }
    }
    proto
}

/// Allocates a magic dom object of a given type.
///
/// All fields must be initialized before converting into a regular `Root<T>`
/// Fields must be initialized in order.
pub fn alloc_dom_object<T: MagicDOMClass>(global: GlobalRef) -> InitRoot<T> {
    alloc_dom_object_with_addr(global, unsafe { return_address() })
}

/// Allocates a magic dom object of a given type.
///
/// This is the same as alloc_dom_object, but with an address field to allow
/// wrapping this function to return an InitRoot<T>.
pub fn alloc_dom_object_with_addr<T: MagicDOMClass>(global: GlobalRef, addr: *const u8)
    -> InitRoot<T> {
    let cx = global.get_cx();
    let _ar = JSAutoRequest::new(cx);
    let _ac = JSAutoCompartment::new(cx, global.handle().get());
    let obj = {
        let proto =
            RootedObject::new(cx, get_proto_object::<T>(cx, global.handle()));
        let obj = unsafe {
            JS_NewObjectWithGivenProto(cx, T::get_jsclass() as *const JSClass,
                                       proto.handle())
        };
        if let Some(id) = T::PROXIED {
            unsafe {
                let handler = RegisterBindings::proxy_handlers[id as usize];
                let obj = RootedObject::new(cx, obj);
                let proxy = NewProxyObject(cx, handler, HandleValue::null(),
                                           ptr::null_mut(), ptr::null_mut(),
                                           ptr::null_mut(), ptr::null_mut());
                SetProxyExtra(proxy, 0, ObjectValue(&*obj.ptr));
                JS_SetReservedSlot(obj.ptr, T::SLOT_COUNT as u32,
                                   ObjectValue(&*proxy));
                obj.ptr
            }
        } else {
            obj
        }
    };

    InitRoot::new(cx, obj, addr)
}

/// Allocates a magic dom global object of a given type.
///
/// All fields must be initialized before converting into a regular `Root<T>`
/// Fields must be initialized in order.
pub fn alloc_dom_global<T: MagicDOMClass + JSTraceable>(cx: *mut JSContext)
    -> InitRoot<T> {
    let obj = {
        let _ar = JSAutoRequest::new(cx);
        let obj =
            RootedObject::new(cx,
                              create_dom_global(cx, T::get_jsclass() as *const JSClass,
                                                Some(trace_hook::<T>)));

        let _ac = JSAutoCompartment::new(cx, obj.ptr);
        let proto =
            RootedObject::new(cx, get_proto_object::<T>(cx, obj.handle()));
        assert!(!proto.ptr.is_null());

        unsafe {
            JS_SetPrototype(cx, obj.handle(), proto.handle());
        }
        RegisterBindings::Register(cx, obj.handle());
        obj.ptr
    };

    InitRoot::new(cx, obj, unsafe { return_address() })
}

struct MagicField<T: MagicCastable, Index: SlotIndex> {
    _t: PhantomData<T>,
    _o: PhantomData<Index>,
}

/// This stores the fields that are available in `Root<T>`
pub struct RealFields {
    /// This is the underlying JSObject.
    /// XXX make private
    pub obj: Cell<*mut JSObject>,
}

/// This stores the fields that are available in `InitRoot<T>`.
pub struct InitFields {
    real: RealFields,
    count: u32,
}

/// This indicates what type of value the slot will store after initialization.
pub enum SlotType {
    /// Any JSVal is allowed. This is the default.
    Any,

    /// Objects only.
    Object,

    /// Int32s only.
    Int32,

    /// Strings only.
    String,

    /// Booleans only.
    Boolean,

    /// Privates only. This will suppress JS accessor generation.
    Private,
}

/// These converters should make as many assumptions as necessary
/// to stay fast.
pub trait MagicCastable {
    /// This sets the number of reserved slots necessary to store a field.
    const SLOT_SIZE: u8 = 1;
    /// This determines what type of value we can always assume to be in the slot
    const SLOT_TYPE: SlotType = SlotType::Any;
    /// This determines whether finalize_slots needs to be called.
    const NEED_FINALIZE: bool = false;
    /// This determines whether heap_size_of and trace need to be called.
    const HEAP_TYPE: bool = false;
    /// This is the type output by `get_from_slots`.
    /// It's usually the same as the type taken in `set_from_slots`,
    /// but it can be different.
    type Target = Self;

    /// Generates an object with data from the private slots starting at idx.
    fn get_from_slots(real: &RealFields, idx: u8) -> Self::Target;

    /// Consumes a given object and saves it into the private slots
    /// starting at `idx`.
    /// If necessary, finalize_slots is called before this.
    fn set_into_slots(real: &RealFields, idx: u8, v: Self);

    /// Does any necessary clean up before this field is set to a new
    /// value or this object is destroyed.
    /// This is called iff `NEED_FINALIZE` is true.
    fn finalize_slots(_real: &RealFields, _idx: u8) { unreachable!() }

    /// Measures the space taken on the heap.
    /// This is called iff `HEAP_TYPE` is true.
    fn heap_size_of(_real: &RealFields, _idx: u8) -> usize { unreachable!() }

    /// Traces the slots.
    /// This is called iff `HEAP_TYPE` is true.
    fn trace(_real: &RealFields, _idx: u8, _tr: *mut JSTracer) { unreachable!() }
}

impl<T: MagicCastable, Index: SlotIndex> MagicField<T, Index> {
    fn init(&mut self, obj: T) {
        if cfg!(debug_assertions) {
            let init = self as *mut _ as *mut InitFields;
            let init = unsafe { &mut *init };

            assert!(Index::IDX as u32 == init.count);
            init.count += <T as MagicCastable>::SLOT_SIZE as u32;
            T::set_into_slots(&init.real, Index::IDX, obj)
        } else {
            let real = &*self as *const _ as *const RealFields;
            let real = unsafe { &*real };
            T::set_into_slots(real, Index::IDX, obj)
        }
    }

    fn set(&self, val: T) {
        let real = &*self as *const _ as *const RealFields;
        let real = unsafe { &*real };
        if <T as MagicCastable>::NEED_FINALIZE {
            T::finalize_slots(real, Index::IDX);
        }
        T::set_into_slots(real, Index::IDX, val)
    }

    fn get(&self) -> T::Target {
        let real = &*self as *const _ as *const RealFields;
        let real = unsafe { &*real };

        T::get_from_slots(real, Index::IDX)
    }
}

/// A magic field that can only be set at init time.
#[allow_unrooted_interior]
pub struct ConstMagicField<T: MagicCastable, Index: SlotIndex> {
    _base: MagicField<T, Index>
}

impl<T: MagicCastable, Index: SlotIndex> ConstMagicField<T, Index> {
    /// For initializing this field.
    pub fn init(&mut self, obj: T) {
        self._base.init(obj)
    }

    /// Get a copy of this field.
    pub fn get(&self) -> T::Target {
        self._base.get()
    }

    /// Get the JS slot access code
    pub fn slot_access_code(name: &str) -> String {
        if T::SLOT_SIZE > 1 {
            return String::new();
        }
        match T::SLOT_TYPE {
            SlotType::Any => {
                format!("    get {}(): any {{ return UnsafeGetReservedSlot(this.obj, {}); }}\n", name, Index::IDX)
            }
            SlotType::Object => {
                format!("    get {}(): Object {{ return UnsafeGetObjectFromReservedSlot(this.obj, {}); }}\n", name, Index::IDX)
            }
            SlotType::Int32 => {
                format!("    get {}(): number {{ return UnsafeGetInt32FromReservedSlot(this.obj, {}); }}\n", name, Index::IDX)
            }
            SlotType::String => {
                format!("    get {}(): string {{ return UnsafeGetStringFromReservedSlot(this.obj, {}); }}\n", name, Index::IDX)
            }
            SlotType::Boolean => {
                format!("    get {}(): boolean {{ return UnsafeGetBooleanFromReservedSlot(this.obj, {}); }}\n", name, Index::IDX)
            }
            SlotType::Private => { String::new() }
        }
    }
}

impl<T: JSTraceable + HeapSizeOf, Index: SlotIndex> Deref for ConstMagicField<Box<T>, Index> {
    type Target = T;

    fn deref<'a>(&'a self) -> &'a T {
        let real = &*self as *const _ as *const RealFields;
        let real = unsafe { &*real };

        let val = JSVal::get_from_slots(real, Index::IDX);
        unsafe { &*(val.to_private() as *const T) }
    }
}

impl<T, Index: SlotIndex> Deref for ConstMagicField<Rc<T>, Index> {
    type Target = T;

    fn deref<'a>(&'a self) -> &'a T {
        let real = &*self as *const _ as *const RealFields;
        let real = unsafe { &*real };

        let val = JSVal::get_from_slots(real, Index::IDX);
        let src: Rc<T> = unsafe { mem::transmute(val.to_private()) };
        let newref: *const T = &*src;
        mem::forget(src);
        unsafe { &*newref }
    }
}

impl<T: MagicDOMClass, Index: SlotIndex> ConstMagicField<JS<T>, Index> {
    /// Returns a `Root<T>` for a given `JS<T>` field.
    pub fn root(&self) -> Root<T> {
        self.get().root()
    }
}

use dom::bindings::global::{GlobalField, GlobalRoot};
impl<Index: SlotIndex> ConstMagicField<GlobalField, Index> {
    /// Returns a GlobalRoot for a GlobalField.
    pub fn root(&self) -> GlobalRoot {
        self.get().root()
    }
}

/// A magic field that can be modified.
#[allow_unrooted_interior]
pub struct MutMagicField<T: MagicCastable, Index: SlotIndex> {
    _base: MagicField<T, Index>
}

impl<T: MagicCastable, Index: SlotIndex> MutMagicField<T, Index> {
    /// For initializing this field.
    pub fn init(&mut self, obj: T) {
        self._base.init(obj)
    }

    /// Sets this field. Can only be called on the script thread.
    pub fn set(&self, val: T) {
        debug_assert!(!task_state::get().is_layout());
        self._base.set(val)
    }

    /// Sets a copy of this field. Can only be called on the script thread.
    pub fn get(&self) -> T::Target {
        debug_assert!(!task_state::get().is_layout());
        self._base.get()
    }

    /// Get the JS slot access code
    pub fn slot_access_code(name: &str) -> String {
        if let SlotType::Private = T::SLOT_TYPE {
            return String::new();
        }
        if T::SLOT_SIZE > 1 {
            return String::new();
        }
        let mut buf = ConstMagicField::<T, Index>::slot_access_code(name);
        match T::SLOT_TYPE {
            SlotType::Any => {
                buf.push_str(&format!("    set {}(val: any) {{ UnsafeSetReservedSlot(this.obj, {}, val); }}\n", name, Index::IDX));
            }
            SlotType::Object => {
                buf.push_str(&format!("    set {}(val: Object) {{ UnsafeSetReservedSlot(this.obj, {}, val); }}\n", name, Index::IDX));
            }
            SlotType::Int32 => {
                buf.push_str(&format!("    set {}(val: number) {{ UnsafeSetReservedSlot(this.obj, {}, val); }}\n", name, Index::IDX));
            }
            SlotType::String => {
                buf.push_str(&format!("    set {}(val: string) {{ UnsafeSetReservedSlot(this.obj, {}, val); }}\n", name, Index::IDX));
            }
            SlotType::Boolean => {
                buf.push_str(&format!("    set {}(val: boolean) {{ UnsafeSetReservedSlot(this.obj, {}, val); }}\n", name, Index::IDX));
            }
            SlotType::Private => {
                unreachable!();
            }
        }
        buf
    }
}

impl<T: MagicDOMClass, Index: SlotIndex> MutMagicField<Option<JS<T>>, Index> {
    /// Retrieve a copy of the current inner value. If it is `None`, it is
    /// initialized with the result of `cb` first.
    pub fn or_init<F>(&self, cb: F) -> Root<T>
        where F: FnOnce() -> Root<T>
    {
        match self.get() {
            Some(inner) => inner.root(),
            None => {
                let inner = cb();
                self.set(Some(JS::from_rooted(&inner)));
                inner
            },
        }
    }
}

/// A mutable magic field that layout can access safely.
#[allow_unrooted_interior]
pub struct LayoutMagicField<T: MagicCastable, Index: SlotIndex> {
    _base: MagicField<T, Index>
}

impl<T: MagicCastable, Index: SlotIndex> LayoutMagicField<T, Index> {
    /// For initializing this field.
    pub fn init(&mut self, obj: T) {
        self._base.init(obj)
    }

    /// Sets this field. Can only be used on the script thread.
    /// This locks the LAYOUT_LOCK. If many fields are being set,
    /// the locking overhead can be reduced with set_no_lock.
    pub fn set(&self, val: T) {
        debug_assert!(!task_state::get().is_layout());
        LAYOUT_LOCK.with(|lock| {
            let _guard = lock.write();
            self._base.set(val)
        });
    }

    /// Sets this field without locking LAYOUT_LOCK.
    /// Can only be used on the script thread, and the caller must lock first.
    pub fn set_no_lock(&self, val: T) {
        debug_assert!(!task_state::get().is_layout());
        debug_assert!(LAYOUT_LOCK.with(|lock| lock.try_read().is_err()));
        self._base.set(val)
    }

    /// Get a copy of this field from a script thread.
    pub fn get(&self) -> T::Target {
        debug_assert!(!task_state::get().is_layout());
        self._base.get()
    }

    /// Get a copy of this field from a layout thread.
    pub fn layout_get(&self) -> T::Target {
        debug_assert!(task_state::get().is_layout());
        // A read lock should be taken on the layout lock separately
        //debug_assert!(LAYOUT_LOCK.with(|lock| lock.try_write().is_err()));
        self._base.get()
    }

    /// Get the JS slot access code
    pub fn slot_access_code(name: &str) -> String {
        ConstMagicField::<T, Index>::slot_access_code(name)
    }
}

impl<T: MagicDOMClass, Index: SlotIndex> LayoutMagicField<Option<JS<T>>, Index> {
    /// Get a LayoutJS for this field.
    pub fn get_inner_as_layout(&self) -> Option<LayoutJS<T>> {
        self.layout_get().map(|inner| unsafe { inner.to_layout() })
    }
}

use std::cell::RefCell;
use dom::node::LayoutData;
impl<Index: SlotIndex> LayoutMagicField<Option<*const RefCell<LayoutData>>, Index> {
    /// Sets this field from the layout thread. Only works for LayoutData.
    pub fn layout_set(&self, val: Option<*const RefCell<LayoutData>>) {
        debug_assert!(task_state::get().is_layout());
        self._base.set(val)
    }
}

impl<Index: SlotIndex> LayoutMagicField<NodeFlags, Index> {
    /// Sets this field from the layout thread. Only works for NodeFlags.
    pub fn layout_set(&self, val: NodeFlags) {
        debug_assert!(task_state::get().is_layout());
        self._base.set(val)
    }
}

impl<T: JSValConversion, Index: SlotIndex> LayoutMagicField<DOMVec<T>, Index> {
    /// Gets this field as a ReadOnlyDOMVec from the layout thread.
    pub fn readonly_get(&self) -> ReadOnlyDOMVec<T> {
        debug_assert!(task_state::get().is_layout());
        let real = &*self as *const _ as *const RealFields;
        let real = unsafe { &*real };
        ReadOnlyDOMVec::from_jsobject(<*mut JSObject>::get_from_slots(real, Index::IDX))
    }
}

/// This is a special type used to reserve slots used by
/// Spidermonkey in global objects. It must be placed after the first 4 slots.
pub struct GlobalObjectSlots;
impl MagicCastable for GlobalObjectSlots {
    // Plus one for DOM_PROTOTYPE_SLOT
    // XXX convert DOM_PROTOTYPE_SLOT into a proper magic field
    const SLOT_SIZE: u8 = (::js::JSCLASS_GLOBAL_SLOT_COUNT + 1 - ::js::JSCLASS_GLOBAL_APPLICATION_SLOTS) as u8;
    const SLOT_TYPE: SlotType = SlotType::Private;
    const NEED_FINALIZE: bool = true;
    const HEAP_TYPE: bool = true;
    type Target = ();

    fn get_from_slots(_real: &RealFields, _idx: u8) {
        unreachable!()
    }

    fn set_into_slots(_real: &RealFields, idx: u8, _v: GlobalObjectSlots) {
        debug_assert!(idx == ::js::JSCLASS_GLOBAL_APPLICATION_SLOTS as u8);
        // These slots are managed by spidermonkey
    }

    fn finalize_slots(real: &RealFields, _idx: u8) {
        unsafe { ::dom::bindings::utils::finalize_global(real.obj.get()) };
    }

    fn heap_size_of(_real: &RealFields, _idx: u8) -> usize {
        0
    }

    fn trace(real: &RealFields, _idx: u8, tr: *mut JSTracer) {
        unsafe { ::dom::bindings::utils::trace_global(tr, real.obj.get()) };
    }
}

// Conversions for general types
impl<X: MagicCastable> MagicCastable for Option<X> {
    const SLOT_SIZE: u8 = <X as MagicCastable>::SLOT_SIZE;
    const SLOT_TYPE: SlotType = SlotType::Any;
    const NEED_FINALIZE: bool = <X as MagicCastable>::NEED_FINALIZE;
    const HEAP_TYPE: bool = <X as MagicCastable>::HEAP_TYPE;
    type Target = Option<X::Target>;

    fn get_from_slots(real: &RealFields, idx: u8) -> Option<X::Target> {
        let val = JSVal::get_from_slots(real, idx);
        if val.is_undefined() {
            None
        } else {
            Some(X::get_from_slots(real, idx))
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: Option<X>) {
        match v {
            Some(v) => X::set_into_slots(real, idx, v),
            None => JSVal::set_into_slots(real, idx, UndefinedValue()),
        }
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        if !Self::NEED_FINALIZE {
            unreachable!();
        }

        let val = JSVal::get_from_slots(real, idx);
        if !val.is_undefined() {
            X::finalize_slots(real, idx);
        }
    }

    fn heap_size_of(real: &RealFields, idx: u8) -> usize {
        if !Self::HEAP_TYPE {
            unreachable!();
        }

        let val = JSVal::get_from_slots(real, idx);
        if !val.is_undefined() {
            X::heap_size_of(real, idx)
        } else {
            0
        }
    }

    fn trace(real: &RealFields, idx: u8, tr: *mut JSTracer) {
        if !Self::HEAP_TYPE {
            unreachable!();
        }

        let val = JSVal::get_from_slots(real, idx);
        if !val.is_undefined() {
            X::trace(real, idx, tr);
        }
    }
}

impl<T: MagicCastable, Index: SlotIndex> ConstMagicField<Option<T>, Index> {
    /// Acts like `Option::is_some`.
    pub fn is_some(&self) -> bool {
        let real = &*self as *const _ as *const RealFields;
        let real = unsafe { &*real };

        !JSVal::get_from_slots(real, Index::IDX).is_undefined()
    }
}

impl<T: MagicCastable, Index: SlotIndex> MutMagicField<Option<T>, Index> {
    /// Acts like `Option::is_some`.
    pub fn is_some(&self) -> bool {
        let real = &*self as *const _ as *const RealFields;
        let real = unsafe { &*real };

        !JSVal::get_from_slots(real, Index::IDX).is_undefined()
    }
}

impl<T: MagicCastable, Index: SlotIndex> LayoutMagicField<Option<T>, Index> {
    /// Acts like `Option::is_some`.
    pub fn is_some(&self) -> bool {
        let real = &*self as *const _ as *const RealFields;
        let real = unsafe { &*real };

        !JSVal::get_from_slots(real, Index::IDX).is_undefined()
    }
}

impl<A: MagicCastable, B: MagicCastable> MagicCastable for (A, B) {
    const SLOT_SIZE: u8 = 3 /* <A as MagicCastable>::SLOT_SIZE + <B as MagicCastable>::SLOT_SIZE */;
    const SLOT_TYPE: SlotType = SlotType::Any;
    const NEED_FINALIZE: bool = true /* <A as MagicCastable>::NEED_FINALIZE && <B as MagicCastable>::NEED_FINALIZE */;
    const HEAP_TYPE: bool = false;
    type Target = (A::Target, B::Target);

    fn get_from_slots(real: &RealFields, idx: u8) -> (A::Target, B::Target) {
        (A::get_from_slots(real, idx), B::get_from_slots(real, idx + 1))
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: (A, B)) {
        debug_assert!((<A as MagicCastable>::SLOT_SIZE + <B as MagicCastable>::SLOT_SIZE) == 3);
        A::set_into_slots(real, idx, v.0);
        B::set_into_slots(real, idx + 1, v.1);
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        if <A as MagicCastable>::NEED_FINALIZE {
            A::finalize_slots(real, idx);
        }
        if <B as MagicCastable>::NEED_FINALIZE {
            B::finalize_slots(real, idx + 1);
        }
    }

    fn heap_size_of(_real: &RealFields, _idx: u8) -> usize {
        unreachable!();
    }

    fn trace(_real: &RealFields, _idx: u8, _tr: *mut JSTracer) {
        unreachable!();
    }
}

impl<T: MagicDOMClass> MagicCastable for JS<T> {
    #[allow(unrooted_must_root)]
    fn get_from_slots(real: &RealFields, idx: u8) -> JS<T> {
        JS::from_jsval(JSVal::get_from_slots(real, idx))
    }

    #[allow(unrooted_must_root)]
    fn set_into_slots(real: &RealFields, idx: u8, v: JS<T>) {
        JSVal::set_into_slots(real, idx, v.get_jsval())
    }
}

impl <T: JSValConversion> MagicCastable for DOMVec<T> {
    fn get_from_slots(real: &RealFields, idx: u8) -> DOMVec<T> {
        let obj = JSVal::get_from_slots(real, idx).to_object();
        DOMVec::from_jsobject(get_tls_jsctx(), obj)
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: DOMVec<T>) {
        JSVal::set_into_slots(real, idx, ObjectValue(unsafe { &*v.get_jsobj() }))
    }
}

impl <T: JSObjectConversion> MagicCastable for DOMMap<T> {
    fn get_from_slots(real: &RealFields, idx: u8) -> DOMMap<T> {
        let obj = JSVal::get_from_slots(real, idx).to_object();
        DOMMap::from_jsobject(get_tls_jsctx(), obj)
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: DOMMap<T>) {
        JSVal::set_into_slots(real, idx, ObjectValue(unsafe { &*v.get_jsobj() }))
    }
}

// Should get rid of this in favor of other magic objects
impl MagicCastable for *mut JSObject {
    fn get_from_slots(real: &RealFields, idx: u8) -> *mut JSObject {
        JSVal::get_from_slots(real, idx).to_object_or_null()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: *mut JSObject) {
        JSVal::set_into_slots(real, idx, ObjectOrNullValue(v))
    }
}

#[repr(C)]
struct RealJSObject {
    _header: [usize; 4],
    slots: [JSVal; 16],
}
impl MagicCastable for JSVal {
    fn get_from_slots(real: &RealFields, idx: u8) -> JSVal {
        if idx < 16 {
            unsafe { (&*(real.obj.get() as *mut RealJSObject)).slots[idx as usize] }
        } else {
            unsafe { JS_GetReservedSlot(real.obj.get(), idx as u32) }
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: JSVal) {
        unsafe { JS_SetReservedSlot(real.obj.get(), idx as u32, v) }
    }
}

impl MagicCastable for u64 {
    const SLOT_SIZE: u8 = 2;

    fn get_from_slots(real: &RealFields, idx: u8) -> u64 {
        let mut val = (u32::get_from_slots(real, idx + 1) as u64) << 32;
        val |= u32::get_from_slots(real, idx) as u64;
        val
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: u64) {
        JSVal::set_into_slots(real, idx, UInt32Value((v & 0xFFFFFFFF) as u32));
        JSVal::set_into_slots(real, idx + 1, UInt32Value(((v >> 32) & 0xFFFFFFFF) as u32));
    }
}

impl MagicCastable for i64 {
    const SLOT_SIZE: u8 = 2;

    fn get_from_slots(real: &RealFields, idx: u8) -> i64 {
        let mut val = (u32::get_from_slots(real, idx + 1) as u64) << 32;
        val |= u32::get_from_slots(real, idx) as u64;
        unsafe { *(&val as *const u64 as *const i64) }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: i64) {
        let v = unsafe { *(&v as *const i64 as *const u64) };
        JSVal::set_into_slots(real, idx, UInt32Value((v & 0xFFFFFFFF) as u32));
        JSVal::set_into_slots(real, idx + 1, UInt32Value(((v >> 32) & 0xFFFFFFFF) as u32));
    }
}

impl MagicCastable for f64 {
    fn get_from_slots(real: &RealFields, idx: u8) -> f64 {
        JSVal::get_from_slots(real, idx).to_double()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: f64) {
        JSVal::set_into_slots(real, idx, DoubleValue(v))
    }
}

impl MagicCastable for f32 {
    fn get_from_slots(real: &RealFields, idx: u8) -> f32 {
        JSVal::get_from_slots(real, idx).to_double() as f32
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: f32) {
        JSVal::set_into_slots(real, idx, DoubleValue(v as f64))
    }
}

impl MagicCastable for i32 {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> i32 {
        JSVal::get_from_slots(real, idx).to_int32()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: i32) {
        JSVal::set_into_slots(real, idx, Int32Value(v))
    }
}

impl MagicCastable for u32 {
    fn get_from_slots(real: &RealFields, idx: u8) -> u32 {
        let val = JSVal::get_from_slots(real, idx);
        if val.is_int32() {
            val.to_int32() as u32
        } else {
            val.to_double() as u32
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: u32) {
        JSVal::set_into_slots(real, idx, UInt32Value(v))
    }
}

impl MagicCastable for i16 {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> i16 {
        JSVal::get_from_slots(real, idx).to_int32() as i16
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: i16) {
        JSVal::set_into_slots(real, idx, Int32Value(v as i32))
    }
}

impl MagicCastable for u16 {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> u16 {
        JSVal::get_from_slots(real, idx).to_int32() as u16
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: u16) {
        JSVal::set_into_slots(real, idx, Int32Value(v as i32))
    }
}

impl MagicCastable for u8 {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> u8 {
        JSVal::get_from_slots(real, idx).to_int32() as u8
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: u8) {
        JSVal::set_into_slots(real, idx, Int32Value(v as i32))
    }
}

impl MagicCastable for bool {
    const SLOT_TYPE: SlotType = SlotType::Boolean;
    fn get_from_slots(real: &RealFields, idx: u8) -> bool {
        JSVal::get_from_slots(real, idx).to_boolean()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: bool) {
        JSVal::set_into_slots(real, idx, BooleanValue(v))
    }
}

use std::slice;
use std::ptr;
use js::jsapi::{JS_StringIsFlat, JS_GetLatin1FlatStringChars, JS_GetTwoByteFlatStringChars, JSFlatString, JS_StringHasLatin1Chars, JS_GetStringLength};
impl MagicCastable for String {
    const SLOT_TYPE: SlotType = SlotType::String;
    fn get_from_slots(real: &RealFields, idx: u8) -> String {
        // This is a variant of jsstring_to_str that assumes flat strings
        let jsstr = JSVal::get_from_slots(real, idx).to_string();
        assert!(!jsstr.is_null());
        unsafe {
            assert!(JS_StringIsFlat(jsstr));
        }

        let latin1 = unsafe { JS_StringHasLatin1Chars(jsstr) };
        let length = unsafe { JS_GetStringLength(jsstr) } as usize;
        let jsstr = jsstr as *mut JSFlatString;
        let mut buf = String::with_capacity(length);
        if latin1 {
            let chars = unsafe {
                JS_GetLatin1FlatStringChars(ptr::null(), jsstr)
            };
            assert!(!chars.is_null());

            for i in 0..(length as isize) {
                unsafe {
                    buf.push(*chars.offset(i) as char);
                }
            }
        } else {
            let chars = unsafe {
                JS_GetTwoByteFlatStringChars(ptr::null(), jsstr)
            };
            assert!(!chars.is_null());

            let potentially_ill_formed_utf16 = unsafe {
                slice::from_raw_parts(chars as *const u16, length)
            };
            for item in ::rustc_unicode::str::utf16_items(potentially_ill_formed_utf16) {
                use ::rustc_unicode::str::Utf16Item::*;
                match item {
                    ScalarValue(c) => buf.push(c),
                    LoneSurrogate(_) => {
                        // FIXME: Add more info like document URL in the message?
                        macro_rules! message {
                            () => {
                                "Found an unpaired surrogate in a DOM string. \
                                 If you see this in real web content, \
                                 please comment on https://github.com/servo/servo/issues/6564"
                            }
                        }
                        if ::util::opts::get().replace_surrogates {
                            error!(message!());
                            buf.push('\u{FFFD}');
                        } else {
                            panic!(concat!(message!(), " Use `-Z replace-surrogates` \
                                on the command line to make this non-fatal."));
                        }
                    }
                }
            }
        }
        buf
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: String) {
        let v: Vec<u16> = v.utf16_units().collect();
        let cx = get_tls_jsctx();
        let _ar = JSAutoRequest::new(cx);
        let _ac = JSAutoCompartment::new(cx, real.obj.get());
        let jsstr = unsafe { JS_NewUCStringCopyN(cx, v.as_ptr(), v.len() as u64) };
        JSVal::set_into_slots(real, idx, StringValue(unsafe { &*jsstr }))
    }
}

impl MagicCastable for ByteString {
    const SLOT_TYPE: SlotType = SlotType::String;
    fn get_from_slots(real: &RealFields, idx: u8) -> ByteString {
        let cx = get_tls_jsctx();
        let val = RootedValue::new(cx, JSVal::get_from_slots(real, idx));
        ByteString::from_jsval(cx, val.handle(), ()).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: ByteString) {
        let v: Vec<u16> = v.into_iter().map(|c| (*c) as u16).collect();
        let cx = get_tls_jsctx();
        let _ar = JSAutoRequest::new(cx);
        let _ac = JSAutoCompartment::new(cx, real.obj.get());
        let jsstr = unsafe { JS_NewUCStringCopyN(cx, v.as_ptr(), v.len() as u64) };
        JSVal::set_into_slots(real, idx, StringValue(unsafe { &*jsstr }))
    }
}

impl<T> MagicCastable for &'static T {
    const SLOT_TYPE: SlotType = SlotType::Private;
    fn get_from_slots(real: &RealFields, idx: u8) -> &'static T {
        unsafe {
            &*(JSVal::get_from_slots(real, idx).to_private() as *const T)
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: &'static T) {
        JSVal::set_into_slots(real, idx, PrivateValue(v as *const T as *const _))
    }
}

impl<T: JSTraceable + HeapSizeOf> MagicCastable for Box<T> {
    const SLOT_SIZE: u8 = 1;
    const SLOT_TYPE: SlotType = SlotType::Private;
    const NEED_FINALIZE: bool = true;
    const HEAP_TYPE: bool = true;
    type Target = *const T;

    fn get_from_slots<'a>(real: &'a RealFields, idx: u8) -> *const T {
        JSVal::get_from_slots(real, idx).to_private() as *const T
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: Box<T>) {
        let v = unsafe { mem::transmute(v) };
        JSVal::set_into_slots(real, idx, PrivateValue(v))
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        let val = JSVal::get_from_slots(real, idx);
        let src: Box<T> = unsafe { mem::transmute(val.to_private()) };
        mem::drop(src);
    }

    fn heap_size_of(real: &RealFields, idx: u8) -> usize {
        let this = unsafe { &*Self::get_from_slots(real, idx) };
        this.heap_size_of_children()
    }

    fn trace(real: &RealFields, idx: u8, tr: *mut JSTracer) {
        let val = JSVal::get_from_slots(real, idx);
        // Need to check in case we GC during object init
        if !val.is_undefined() {
            let this = unsafe { &*(val.to_private() as *const T) };
            this.trace(tr)
        }
    }
}

impl<T> MagicCastable for *const T {
    const SLOT_TYPE: SlotType = SlotType::Private;
    fn get_from_slots(real: &RealFields, idx: u8) -> *const T {
        JSVal::get_from_slots(real, idx).to_private() as *mut T
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: *const T) {
        JSVal::set_into_slots(real, idx, PrivateValue(v as *const _))
    }
}

impl<T> MagicCastable for Rc<T> {
    const SLOT_TYPE: SlotType = SlotType::Private;
    const NEED_FINALIZE: bool = true;

    fn get_from_slots(real: &RealFields, idx: u8) -> Rc<T> {
        let val = JSVal::get_from_slots(real, idx);
        let src: Rc<T> = unsafe { mem::transmute(val.to_private()) };
        let newref = src.clone();
        mem::forget(src);
        newref
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: Rc<T>) {
        let v = unsafe { mem::transmute(v) };
        JSVal::set_into_slots(real, idx, PrivateValue(v))
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        let val = JSVal::get_from_slots(real, idx);
        let src: Rc<T> = unsafe { mem::transmute(val.to_private()) };
        mem::drop(src);
    }
}

impl<T> MagicCastable for Arc<T> {
    const SLOT_TYPE: SlotType = SlotType::Private;
    const NEED_FINALIZE: bool = true;

    fn get_from_slots(real: &RealFields, idx: u8) -> Arc<T> {
        let val = JSVal::get_from_slots(real, idx);
        let src: Arc<T> = unsafe { mem::transmute(val.to_private()) };
        let newref = src.clone();
        mem::forget(src);
        newref
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: Arc<T>) {
        let v = unsafe { mem::transmute(v) };
        JSVal::set_into_slots(real, idx, PrivateValue(v))
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        let val = JSVal::get_from_slots(real, idx);
        let src: Arc<T> = unsafe { mem::transmute(val.to_private()) };
        mem::drop(src);
    }
}

// Misc converters
use cssparser::RGBA;
impl MagicCastable for RGBA {
    fn get_from_slots(real: &RealFields, idx: u8) -> RGBA {
        let v = u32::get_from_slots(real, idx);
        RGBA {
            red: ((v >> 16) & 0xFF) as f32 / 255.,
            green: ((v >> 8) & 0xFF) as f32 / 255.,
            blue: (v & 0xFF) as f32 / 255.,
            alpha: ((v >> 24) & 0xFF) as f32 / 255.,
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: RGBA) {
        let r = (v.red * 255.).round() as u32;
        let g = (v.green * 255.).round() as u32;
        let b = (v.blue * 255.).round() as u32;
        let a = (v.alpha * 255.).round() as u32;
        let v = (a << 24) | (r << 16) | (g << 8) | b;

        u32::set_into_slots(real, idx, v);
    }
}

use msg::constellation_msg::SubpageId;
impl MagicCastable for SubpageId {
    fn get_from_slots(real: &RealFields, idx: u8) -> SubpageId {
        SubpageId(u32::get_from_slots(real, idx))
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: SubpageId) {
        u32::set_into_slots(real, idx, v.0);
    }
}

use msg::constellation_msg::{PipelineId, PipelineNamespaceId, PipelineIndex};
impl MagicCastable for PipelineId {
    const SLOT_SIZE: u8 = 2;

    fn get_from_slots(real: &RealFields, idx: u8) -> PipelineId {
        PipelineId {
            namespace_id: PipelineNamespaceId(u32::get_from_slots(real, idx)),
            index: PipelineIndex(u32::get_from_slots(real, idx + 1)),
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: PipelineId) {
        u32::set_into_slots(real, idx, v.namespace_id.0);
        u32::set_into_slots(real, idx + 1, v.index.0);
    }
}

use msg::constellation_msg::WorkerId;
impl MagicCastable for WorkerId {
    fn get_from_slots(real: &RealFields, idx: u8) -> WorkerId {
        WorkerId(u32::get_from_slots(real, idx))
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: WorkerId) {
        u32::set_into_slots(real, idx, v.0);
    }
}

use dom::filereader::GenerationId;
impl MagicCastable for GenerationId {
    fn get_from_slots(real: &RealFields, idx: u8) -> GenerationId {
        GenerationId(u32::get_from_slots(real, idx))
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: GenerationId) {
        u32::set_into_slots(real, idx, v.0);
    }
}

// Misc DOM converters
use dom::event::EventPhase;
impl MagicCastable for EventPhase {
    fn get_from_slots(real: &RealFields, idx: u8) -> EventPhase {
        EventPhase::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: EventPhase) {
        i32::set_into_slots(real, idx, v as i32);
    }
}


use dom::htmlbuttonelement::ButtonType;
impl MagicCastable for ButtonType {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> ButtonType {
        ButtonType::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: ButtonType) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use dom::htmlheadingelement::HeadingLevel;
impl MagicCastable for HeadingLevel {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> HeadingLevel {
        HeadingLevel::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: HeadingLevel) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use dom::node::NodeFlags;
impl MagicCastable for NodeFlags {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> NodeFlags {
        NodeFlags::from_bits(i32::get_from_slots(real, idx) as u8).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: NodeFlags) {
        i32::set_into_slots(real, idx, v.bits() as i32);
    }
}

use dom::element::EventState;
impl MagicCastable for EventState {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> EventState {
        EventState::from_bits(i32::get_from_slots(real, idx) as u8).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: EventState) {
        i32::set_into_slots(real, idx, v.bits() as i32);
    }
}

use dom::domexception::DOMErrorName;
impl MagicCastable for DOMErrorName {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> DOMErrorName {
        DOMErrorName::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: DOMErrorName) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use dom::websocket::WebSocketRequestState;
impl MagicCastable for WebSocketRequestState {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> WebSocketRequestState {
        WebSocketRequestState::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: WebSocketRequestState) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use dom::bindings::codegen::Bindings::WebSocketBinding::BinaryType;
impl MagicCastable for BinaryType {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> BinaryType {
        BinaryType::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: BinaryType) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use dom::xmlhttprequest::XMLHttpRequestState;
impl MagicCastable for XMLHttpRequestState {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> XMLHttpRequestState {
        XMLHttpRequestState::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: XMLHttpRequestState) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use dom::htmlinputelement::InputType;
impl MagicCastable for InputType {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> InputType {
        InputType::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: InputType) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use canvas_traits::WebGLError;
impl MagicCastable for WebGLError {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> WebGLError {
        WebGLError::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: WebGLError) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use msg::constellation_msg::Key;
impl MagicCastable for Key {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> Key {
        Key::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: Key) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use net_traits::storage_task::StorageType;
impl MagicCastable for StorageType {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> StorageType {
        StorageType::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: StorageType) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use dom::bindings::codegen::Bindings::DocumentBinding::DocumentReadyState;
impl MagicCastable for DocumentReadyState {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> DocumentReadyState {
        DocumentReadyState::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: DocumentReadyState) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use selectors::parser::PseudoElement;
impl MagicCastable for PseudoElement {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> PseudoElement {
        match i32::get_from_slots(real, idx) {
            0 => PseudoElement::Before,
            1 => PseudoElement::After,
            _ => unreachable!(),
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: PseudoElement) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use html5ever::tree_builder::interface::QuirksMode;
impl MagicCastable for QuirksMode {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> QuirksMode {
        match i32::get_from_slots(real, idx) {
            0 => QuirksMode::Quirks,
            1 => QuirksMode::LimitedQuirks,
            2 => QuirksMode::NoQuirks,
            _ => unreachable!(),
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: QuirksMode) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use dom::filereader::FileReaderReadyState;
impl MagicCastable for FileReaderReadyState {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> FileReaderReadyState {
        FileReaderReadyState::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: FileReaderReadyState) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use util::str::LengthOrPercentageOrAuto;
use app_units::Au;
use js::jsval::NullValue;
impl MagicCastable for LengthOrPercentageOrAuto {
    fn get_from_slots(real: &RealFields, idx: u8) -> LengthOrPercentageOrAuto {
        let v = JSVal::get_from_slots(real, idx);
        if v.is_null() {
            return LengthOrPercentageOrAuto::Auto;
        }
        if v.is_double() {
            return LengthOrPercentageOrAuto::Percentage(v.to_double() as f32);
        }
        if v.is_int32() {
            return LengthOrPercentageOrAuto::Length(Au(v.to_int32()));
        }
        unreachable!();
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: LengthOrPercentageOrAuto) {
        let v = match v {
            LengthOrPercentageOrAuto::Auto => NullValue(),
            LengthOrPercentageOrAuto::Percentage(percent) => DoubleValue(percent as f64),
            LengthOrPercentageOrAuto::Length(len) => Int32Value(len.0),
        };
        JSVal::set_into_slots(real, idx, v)
    }
}

use dom::htmlcanvaselement::CanvasContext;
use dom::canvasrenderingcontext2d::CanvasRenderingContext2D;
use dom::webglrenderingcontext::WebGLRenderingContext;
impl MagicCastable for CanvasContext {
    const SLOT_TYPE: SlotType = SlotType::Object;
    #[allow(unrooted_must_root)]
    fn get_from_slots(real: &RealFields, idx: u8) -> CanvasContext {
        let obj = <*mut JSObject>::get_from_slots(real, idx);
        match native_from_reflector_jsmanaged::<CanvasRenderingContext2D>(obj) {
            Ok(root) => {
                return CanvasContext::Context2d(JS::from_rooted(&root));
            },
            Err(_) => ()
        }
        match native_from_reflector_jsmanaged::<WebGLRenderingContext>(obj) {
            Ok(root) => {
                return CanvasContext::WebGL(JS::from_rooted(&root));
            },
            Err(_) => ()
        }
        unreachable!();
    }

    #[allow(unrooted_must_root)]
    fn set_into_slots(real: &RealFields, idx: u8, v: CanvasContext) {
        let v = match v {
            CanvasContext::Context2d(ref obj) => obj.get_jsobj(),
            CanvasContext::WebGL(ref obj) => obj.get_jsobj(),
        };

        <*mut JSObject>::set_into_slots(real, idx, v);
    }
}

use dom::webglshader::ShaderCompilationStatus;
impl MagicCastable for ShaderCompilationStatus {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> ShaderCompilationStatus {
        ShaderCompilationStatus::from_i32(i32::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: ShaderCompilationStatus) {
        i32::set_into_slots(real, idx, v as i32);
    }
}

use dom::webglrenderingcontext::TextureUnpacking;
impl MagicCastable for TextureUnpacking {
    const SLOT_TYPE: SlotType = SlotType::Int32;
    fn get_from_slots(real: &RealFields, idx: u8) -> TextureUnpacking {
        TextureUnpacking::from_bits(i32::get_from_slots(real, idx) as u8).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: TextureUnpacking) {
        i32::set_into_slots(real, idx, v.bits() as i32);
    }
}

use encoding::types::EncodingRef;
use std::raw::TraitObject;
impl MagicCastable for EncodingRef {
    const SLOT_SIZE: u8 = 2;

    fn get_from_slots(real: &RealFields, idx: u8) -> EncodingRef {
        unsafe {
            mem::transmute(TraitObject {
                data: JSVal::get_from_slots(real, idx).to_private() as *mut _,
                vtable: JSVal::get_from_slots(real, idx + 1).to_private() as *mut _,
            })
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: EncodingRef) {
        let v: TraitObject = unsafe { mem::transmute(v) };
        JSVal::set_into_slots(real, idx, PrivateValue(v.data as *const _));
        JSVal::set_into_slots(real, idx + 1, PrivateValue(v.vtable as *const _));
    }
}

use url::Url;
use std::str::FromStr;
impl MagicCastable for Url {
    const SLOT_TYPE: SlotType = SlotType::String;
    fn get_from_slots(real: &RealFields, idx: u8) -> Url {
        Url::from_str(&String::get_from_slots(real, idx)).unwrap()
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: Url) {
        String::set_into_slots(real, idx, v.to_string());
    }
}

use style::properties::{PropertyDeclarationBlock, PropertyDeclaration};
impl MagicCastable for PropertyDeclarationBlock {
    const SLOT_SIZE: u8 = 2;
    const NEED_FINALIZE: bool = true;

    fn get_from_slots(real: &RealFields, idx: u8) -> PropertyDeclarationBlock {
        PropertyDeclarationBlock {
            important: <Arc<Vec<PropertyDeclaration>>>::get_from_slots(real, idx),
            normal: <Arc<Vec<PropertyDeclaration>>>::get_from_slots(real, idx + 1),
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: PropertyDeclarationBlock) {
        <Arc<Vec<PropertyDeclaration>>>::set_into_slots(real, idx, v.important);
        <Arc<Vec<PropertyDeclaration>>>::set_into_slots(real, idx + 1, v.normal);
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        <Arc<Vec<PropertyDeclaration>>>::finalize_slots(real, idx);
        <Arc<Vec<PropertyDeclaration>>>::finalize_slots(real, idx + 1);
    }
}

use dom::nodeiterator;
use dom::bindings::codegen::Bindings::NodeFilterBinding::NodeFilter;
impl MagicCastable for nodeiterator::Filter {
    const SLOT_SIZE: u8 = 2;
    const NEED_FINALIZE: bool = true;

    fn get_from_slots(real: &RealFields, idx: u8) -> nodeiterator::Filter {
        match i32::get_from_slots(real, idx) {
            0 => {
                nodeiterator::Filter::None
            },
            1 => {
                let f = JSVal::get_from_slots(real, idx + 1).to_private();
                nodeiterator::Filter::Native(unsafe { mem::transmute(f) })
            }
            2 => {
                let f = <Rc<NodeFilter>>::get_from_slots(real, idx + 1);
                nodeiterator::Filter::Callback(f)
            }
            _ => unreachable!(),
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: nodeiterator::Filter) {
        let first = match v {
            nodeiterator::Filter::None => Int32Value(0),
            nodeiterator::Filter::Native(_) => Int32Value(1),
            nodeiterator::Filter::Callback(_) => Int32Value(2),
        };

        JSVal::set_into_slots(real, idx, first);

        match v {
            nodeiterator::Filter::None => (),
            nodeiterator::Filter::Native(f) => {
                JSVal::set_into_slots(real, idx + 1, PrivateValue(f as *const _));
            },
            nodeiterator::Filter::Callback(ref cb) => {
                <Rc<NodeFilter>>::set_into_slots(real, idx + 1, cb.clone());
            },
        };
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        if i32::get_from_slots(real, idx) == 2 {
            <Rc<NodeFilter>>::finalize_slots(real, idx + 1);
        }
    }
}

use dom::treewalker;
impl MagicCastable for treewalker::Filter {
    const SLOT_SIZE: u8 = 2;
    const NEED_FINALIZE: bool = true;

    fn get_from_slots(real: &RealFields, idx: u8) -> treewalker::Filter {
        match i32::get_from_slots(real, idx) {
            0 => {
                treewalker::Filter::None
            },
            1 => {
                let f = JSVal::get_from_slots(real, idx + 1).to_private();
                treewalker::Filter::Native(unsafe { mem::transmute(f) })
            }
            2 => {
                let f = <Rc<NodeFilter>>::get_from_slots(real, idx + 1);
                treewalker::Filter::JS(f)
            }
            _ => unreachable!(),
        }
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: treewalker::Filter) {
        let first = match v {
            treewalker::Filter::None => Int32Value(0),
            treewalker::Filter::Native(_) => Int32Value(1),
            treewalker::Filter::JS(_) => Int32Value(2),
        };

        JSVal::set_into_slots(real, idx, first);

        match v {
            treewalker::Filter::None => (),
            treewalker::Filter::Native(f) => {
                JSVal::set_into_slots(real, idx + 1, PrivateValue(f as *const _));
            },
            treewalker::Filter::JS(ref cb) => {
                <Rc<NodeFilter>>::set_into_slots(real, idx + 1, cb.clone());
            },
        };
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        if i32::get_from_slots(real, idx) == 2 {
            <Rc<NodeFilter>>::finalize_slots(real, idx + 1);
        }
    }
}

use dom::nodelist::NodeListType;
use dom::nodelist::ChildrenList;
impl MagicCastable for NodeListType {
    #[allow(unrooted_must_root)]
    fn get_from_slots(real: &RealFields, idx: u8) -> NodeListType {
        use dom::node::Node;
        let obj = <*mut JSObject>::get_from_slots(real, idx);
        // XXX Do this in reverse? Should be cheaper to check for an array.
        match native_from_reflector_jsmanaged::<ChildrenList>(obj) {
            Ok(root) => {
                NodeListType::Children(root)
            },
            Err(_) => {
                let cx = get_tls_jsctx();
                NodeListType::Simple(DOMVec::from_jsobject(cx, obj))
            }
        }
    }

    #[allow(unrooted_must_root)]
    fn set_into_slots(real: &RealFields, idx: u8, v: NodeListType) {
        let obj = match v {
            NodeListType::Simple(v) => v.get_jsobj(),
            NodeListType::Children(v) => v.get_jsobj(),
        };
        <*mut JSObject>::set_into_slots(real, idx, obj);
    }
}

use string_cache::atom::Atom;
impl MagicCastable for Atom {
    const SLOT_SIZE: u8 = 2;
    const NEED_FINALIZE: bool = true;

    fn get_from_slots(real: &RealFields, idx: u8) -> Atom {
        let atom = Atom {
            data: u64::get_from_slots(real, idx),
        };
        let new = atom.clone();
        mem::forget(atom);
        new
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: Atom) {
        u64::set_into_slots(real, idx, v.data);
        mem::forget(v);
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        let atom = Atom {
            data: u64::get_from_slots(real, idx),
        };
        mem::drop(atom);
    }
}

use string_cache::namespace::Namespace;
impl MagicCastable for Namespace {
    const SLOT_SIZE: u8 = 2;
    const NEED_FINALIZE: bool = true;

    fn get_from_slots(real: &RealFields, idx: u8) -> Namespace {
        Namespace(Atom::get_from_slots(real, idx))
    }

    fn set_into_slots(real: &RealFields, idx: u8, v: Namespace) {
        Atom::set_into_slots(real, idx, v.0);
    }

    fn finalize_slots(real: &RealFields, idx: u8) {
        Atom::finalize_slots(real, idx);
    }
}

use dom::formdata::FormDatum;
impl JSValConversion for FormDatum {
    #[allow(unrooted_must_root)]
    fn get_jsval(&self) -> JSVal {
        match self {
            &FormDatum::StringData(ref s) => {
                let s: Vec<u16> = s.utf16_units().collect();
                let cx = get_tls_jsctx();
                let _ar = JSAutoRequest::new(cx);
                let jsstr = unsafe { JS_NewUCStringCopyN(cx, s.as_ptr(), s.len() as u64) };
                unsafe { StringValue(&*jsstr) }
            },
            &FormDatum::FileData(file) => {
                unsafe { ObjectValue(&*file.get_jsobj()) }
            },
        }
    }

    #[allow(unrooted_must_root)]
    fn from_jsval(val: JSVal) -> FormDatum {
        if val.is_object() {
            FormDatum::FileData(unsafe { JS::from_jsobj(val.to_object()) })
        } else if val.is_string() {
            let cx = get_tls_jsctx();
            let _ar = JSAutoRequest::new(cx);
            let val = RootedValue::new(cx, val);
            let jsstr = ToString(cx, val.handle());
            assert!(!jsstr.is_null());

            FormDatum::StringData(jsstring_to_str(cx, jsstr))
        } else {
            unreachable!();
        }
    }
}
